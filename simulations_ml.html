<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="canonical" href="https://neuropsis.org/simulations_ml.html">
    <meta name="description" content="Overview of my work in neural data simulation and machine learning.">
    <title>Simulation and Machine Learning | Remy Cohan</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">

    <style>
        /* --- My style, that's right! --- */
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f7f9fc, #dfe6e9);
        }

        /* touche pas s'il te plaît!!!! */
        header.logo-header {
            height: 190px; /* fixed, elegant, no jumping, just like me */
            background-image: url("images/Logo_small.png");
            background-size: cover;        /* fills width cleanly */
            background-position: center 55%;   /* logo stays centred */
            background-repeat: no-repeat;
            box-shadow: 0px 3px 10px rgba(0, 0, 0, 0.18);
        }

        /* NAV */
        nav {
            position: relative;
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 10px 0;
            background-color: #000;
            box-shadow: none;
        }

        nav a {
            color: #fff;
            text-decoration: none;
            padding: 10px 16px;
            font-weight: 500;
            white-space: nowrap;
        }

        nav a:hover {
            color: #d0d0d0;
        }

        /* Burger king, combo 1, with bacon: Hamburger button sits INSIDE nav, left side, never blocks banner */
        .quicklinks-btn {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 40px;
            width: 44px;
            border: 1px solid rgba(255,255,255,0.18);
            background: rgba(255,255,255,0.06);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            transition: background 0.2s, border-color 0.2s, transform 0.2s;
        }

        .quicklinks-btn:hover {
            background: rgba(255,255,255,0.10);
            border-color: rgba(255,255,255,0.28);
        }

        .quicklinks-btn:active {
            transform: translateY(-50%) scale(0.98);
        }

        /* --- QUICK LINKS SIDEBAR (click 2 open) --- */
        .sidebar-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
            z-index: 1000;
        }

        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 280px;
            background-color: #0b0f14; /* premium dark */
            box-shadow: 10px 0px 30px rgba(0, 0, 0, 0.35);
            transform: translateX(-105%);
            transition: transform 0.25s ease;
            z-index: 1001;
            padding: 18px 18px 14px 18px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        .sidebar-overlay.open {
            opacity: 1;
            pointer-events: auto;
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 12px;
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.10);
        }

        .sidebar h3 {
            margin: 0;
            color: #fff;
            font-size: 1.05em;
            letter-spacing: 0.2px;
        }

        .sidebar-close {
            border: 1px solid rgba(255,255,255,0.18);
            background: rgba(255,255,255,0.06);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            padding: 8px 10px;
            transition: background 0.2s, border-color 0.2s;
        }

        .sidebar-close:hover {
            background: rgba(255,255,255,0.10);
            border-color: rgba(255,255,255,0.28);
        }

        .sidebar a {
            color: #e8e8e8;
            text-decoration: none;
            display: block;
            padding: 10px 10px;
            border-radius: 10px;
            margin-bottom: 8px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            transition: background 0.2s, border-color 0.2s, transform 0.12s;
            font-size: 0.95em;
        }

        .sidebar a:hover {
            background: rgba(255,255,255,0.07);
            border-color: rgba(255,255,255,0.14);
            transform: translateX(2px);
        }

        /* sidebar tab is no longer needed visually, yeah! */
        .sidebar-tab { display: none; }

        main {
            margin-left: 0;
            padding: 40px;
            background-color: #ffffff;
            box-shadow: 0px 3px 15px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            max-width: 1200px;
            margin: 20px auto;
        }

        /* --- SIMULATION STYLES --- */
        .explanation-grid {
            display: grid;
            grid-telate-columns: 1fr 1fr;
            gap: 20px;
            background: #f0f7fb;
            border-left: 5px solid #2E86C1;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 30px;
            font-size: 0.9em;
        }
        .exp-col h4 { margin-top: 0; color: #2E86C1; margin-bottom: 8px; }
        .exp-col ul { margin: 0; padding-left: 20px; }
        .exp-col li { margin-bottom: 5px; }

        .sim-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            width: 100%;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e1e4e8;
            margin-bottom: 40px;
            box-sizing: border-box;
        }

        .canvas-wrapper {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            position: relative;
            flex: 1 1 500px;
        }

        canvas {
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
            width: 100%;
            height: 350px;
        }

        .controls {
            flex: 1 1 300px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .control-group { margin-bottom: 15px; }
        .control-group h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            color: #555;
        }

        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .slider-label { flex: 2; font-size: 0.85em; font-weight: 500;}
        input[type=range] { flex: 3; margin: 0 10px; cursor: pointer; }
        .slider-value { flex: 1; text-align: right; font-family: monospace; font-size: 0.85em; color: #555; }

        .preset-btn {
            padding: 6px 12px;
            margin-right: 5px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #fff;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        .preset-btn:hover { background: #f0f0f0; border-color: #bbb; }

        /* Specific header colours, because in general I'm a very specific person */
        .na-header { color: #27ae60 !important; border-bottom-color: #27ae60 !important; }
        .k-header { color: #2980b9 !important; border-bottom-color: #2980b9 !important; }
        .input-header { color: #e74c3c !important; border-bottom-color: #e74c3c !important; }

        @media (max-width: 900px) {
            nav {
                gap: 10px;
                padding: 10px 8px;
                flex-wrap: wrap;
            }
            nav a { padding: 8px 10px; }
        }

        @media (max-width: 768px) {
            main { padding: 20px; margin: 10px; }
            .canvas-wrapper, .controls { flex: 1 1 100%; }
            .explanation-grid { grid-template-columns: 1fr; }
            .quicklinks-btn { left: 10px; }
        }
    </style>
</head>

<body>
    <header class="logo-header"></header>

    <nav>
        <!-- hamburger for Quick Links, getting mo phat!  -->
        <button class="quicklinks-btn" type="button" onclick="toggleSidebar()" aria-label="Open quick links" aria-controls="quicklinksSidebar" aria-expanded="false">☰</button>

        <a href="index.html">Home</a>
        <a href="Projects.html">Current Projects</a>
        <a href="nifti_viewer.html">Interactive MRI Viewer</a>
        <a href="plots.html">Statistics and Plotting</a>
        <a href="neuro_analysis.html">Neuroimaging Analysis Scripts</a>
        <a href="posters.html">Conference Posters</a>
    </nav>

    <!-- overlay -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()" aria-hidden="true"></div>

    <!-- sidebar -->
    <aside class="sidebar" id="quicklinksSidebar" aria-label="Quick Links">
        <div class="sidebar-header">
            <h3>Quick Links</h3>
            <button class="sidebar-close" type="button" onclick="closeSidebar()" aria-label="Close quick links">Close</button>
        </div>

        <a href="https://github.com/CohanR/Hodgkin-Huxley_Simulation">Hodgkin Huxley Simulation</a>
        <a href="https://github.com/CohanR/Action_Potential_Simulation">Action Potential Simulation</a>
        <a href="https://github.com/CohanR/TMS_ElectricField_Group_Simulation">TMS Electric Field Simulation</a>
        <a href="https://github.com/CohanR/MotorEvokedPotentials_Propofol_ML">Propofol and MEP ML Algorithm</a>
    </aside>

    <main>
        <h1>Simulation & Machine Learning</h1>
        <p>Below are some of my simulation and ML scripts:</p>

        <section>
            <h2>Interactive Hodgkin-Huxley Lab</h2>

            <div class="explanation-grid">
                <div class="exp-col">
                    <h4>The Basics</h4>
                    <ul>
                        <li><strong>Action Potential:</strong> The electrical "spike" when a neuron fires.</li>
                        <li><strong>Depolarization:</strong> Voltage rises sharply. Think of this as the "gas pedal".</li>
                        <li><strong>Hyperpolarization:</strong> Voltage drops below rest. Think of this as the "brake".</li>
                    </ul>
                </div>
                <div class="exp-col">
                    <h4>The Chemistry</h4>
                    <ul>
                        <li><strong>Sodium (Na+):</strong> Positive charge flowing in causes the spike (Depolarisation).</li>
                        <li><strong>Potassium (K+):</strong> Positive charge flowing out resets the cell (Hyperpolarisation).</li>
                        <li><strong>Resting memberane potential:</strong> -65 mV.</li>
                        <li><small><em> Hodgkin & Huxley (1952) → A quantitative description of membrane current and its application to conduction and excitation in nerve.</em></small></li>
                    </ul>
                </div>
            </div>

            <div class="sim-container">
                <div class="canvas-wrapper">
                    <canvas id="simCanvas" width="600" height="350"></canvas>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <h3>Quick Presets</h3>
                        <button class="preset-btn" onclick="applyPreset('normal')">Normal Fire</button>
                        <button class="preset-btn" onclick="applyPreset('low_na')">Low Sodium</button>
                        <button class="preset-btn" onclick="applyPreset('high_k')">High Potassium</button>
                    </div>

                    <div class="control-group">
                        <h3 class="input-header">Stimulation</h3>
                        <div class="slider-container">
                            <span class="slider-label">Current (I)</span>
                            <input type="range" id="i_ext" min="0" max="50" step="0.5" value="10">
                            <span class="slider-value" id="val_i_ext">10.0 µA</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3 class="na-header">Sodium (Na+)</h3>
                        <div class="slider-container">
                            <span class="slider-label">Conductance</span>
                            <input type="range" id="g_na" min="0" max="250" value="120">
                            <span class="slider-value" id="val_g_na">120 mS</span>
                        </div>
                        <div class="slider-container">
                            <span class="slider-label">Potential (E)</span>
                            <input type="range" id="e_na" min="0" max="100" value="50">
                            <span class="slider-value" id="val_e_na">50 mV</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3 class="k-header">Potassium (K+)</h3>
                        <div class="slider-container">
                            <span class="slider-label">Conductance</span>
                            <input type="range" id="g_k" min="0" max="100" value="36">
                            <span class="slider-value" id="val_g_k">36 mS</span>
                        </div>
                        <div class="slider-container">
                            <span class="slider-label">Potential (E)</span>
                            <input type="range" id="e_k" min="-100" max="-50" value="-77">
                            <span class="slider-value" id="val_e_k">-77 mV</span>
                        </div>
                    </div>

                    <button onclick="resetDefaults()" style="width:100%; padding:10px; background:#95a5a6; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.9em; margin-top:10px; font-weight:600;">Reset Simulation</button>
                </div>
            </div>

            <p>Get the Python source code here:</p>
            <a href="https://github.com/CohanR/Hodgkin-Huxley_Simulation" target="_blank">View Hodgkin Huxley Simulation Code on GitHub</a>
        </section>

        <!-- ======== ADDED: McCulloch–Pitts section goes directly under Hodgkin–Huxley ======== -->
        <section>
            <h2>McCulloch–Pitts Neuron (Binary Threshold Model)</h2>

            <div class="explanation-grid">
                <div class="exp-col">
                    <h4>What it is</h4>
                    <ul>
                        <li><strong>Inputs:</strong> binary (0/1), like spikes present vs absent.</li>
                        <li><strong>Weights:</strong> scale each input (excitatory if positive, inhibitory if negative).</li>
                        <li><strong>Bias:</strong> a constant offset that shifts firing up/down.</li>
                        <li><strong>Threshold (θ):</strong> fires if the weighted sum reaches it.</li>
                        <li><strong>Output:</strong> binary (0/1), a simplified “fires / does not fire”.</li>
                    </ul>
                </div>
                <div class="exp-col">
                    <h4>Why you should care</h4>
                    <ul>
                        <li>This is the clean ancestor of the perceptron and modern neural nets.</li>
                        <li>It shows how logic gates (AND / OR / NOT / NAND) can be implemented with a single unit.</li>
                        <li><strong>Important limitation:</strong> XOR cannot be done with a single unit; you need multiple layers.</li>
                        <li><small><em> McCulloch & Pitts (1943) → foundational formalism for neural computation.</em></small></li>
                    </ul>
                </div>
            </div>

            <div class="sim-container">
                <div class="canvas-wrapper">
                    <canvas id="mpCanvas" width="600" height="350"></canvas>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <h3>Inputs</h3>
                        <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
                            <label style="display:flex; gap:8px; align-items:center;">
                                <input type="checkbox" id="mp_x1" checked>
                                <span>x1</span>
                            </label>
                            <label style="display:flex; gap:8px; align-items:center;">
                                <input type="checkbox" id="mp_x2" checked>
                                <span>x2</span>
                            </label>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>Weights + Threshold</h3>

                        <div class="slider-container">
                            <span class="slider-label">w1</span>
                            <input type="range" id="mp_w1" min="-5" max="5" step="0.1" value="1">
                            <span class="slider-value" id="val_mp_w1">1.0</span>
                        </div>

                        <div class="slider-container">
                            <span class="slider-label">w2</span>
                            <input type="range" id="mp_w2" min="-5" max="5" step="0.1" value="1">
                            <span class="slider-value" id="val_mp_w2">1.0</span>
                        </div>

                        <div class="slider-container">
                            <span class="slider-label">bias</span>
                            <input type="range" id="mp_b" min="-5" max="5" step="0.1" value="0">
                            <span class="slider-value" id="val_mp_b">0.0</span>
                        </div>

                        <div class="slider-container">
                            <span class="slider-label">threshold (θ)</span>
                            <input type="range" id="mp_th" min="-5" max="5" step="0.1" value="1.5">
                            <span class="slider-value" id="val_mp_th">1.5</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>Logic presets</h3>
                        <button class="preset-btn" onclick="mpApplyPreset('AND')">AND</button>
                        <button class="preset-btn" onclick="mpApplyPreset('OR')">OR</button>
                        <button class="preset-btn" onclick="mpApplyPreset('NAND')">NAND</button>
                        <button class="preset-btn" onclick="mpApplyPreset('NOT_X1')">NOT x1</button>
                    </div>

                    <div class="control-group">
                        <h3>Output</h3>
                        <div id="mp_readout" style="font-weight:700; font-size:1.05em;">
                            y = 0
                        </div>
                        <div style="color:#666; margin-top:6px; font-size:0.95em;" id="mp_math"></div>

                        <!-- ADDED: Plain-English explanation so the math isn't random numbers -->
                        <div style="color:#666; margin-top:8px; font-size:0.95em; line-height:1.4;">
                            <div><strong>x1, x2</strong> are inputs (0 = off, 1 = on).</div>
                            <div><strong>w1, w2</strong> are weights (positive excites, negative inhibits).</div>
                            <div><strong>s</strong> = w1·x1 + w2·x2 + bias, and the neuron fires if <strong>s ≥ θ</strong>.</div>
                        </div>
                    </div>

                    <button onclick="mpReset()" style="width:100%; padding:10px; background:#95a5a6; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.9em; margin-top:10px; font-weight:600;">
                        Reset
                    </button>
                </div>
            </div>
        </section>
        <!-- ======== END ADDED SECTION ======== -->

        <hr style="border: 0; height: 1px; background: #ddd; margin: 40px 0;">

        <section>
            <h2>Action Potentials Simulation</h2>
            <img src="images/Action_Potential_Sim_Remy_Cohan.gif" alt="Action Potentials Simulation GIF" style="max-width:100%; height:auto; border-radius:8px;">
            <p>Checkout the Action Potentials Simulation on GitHub:</p>
            <a href="https://github.com/CohanR/Action_Potential_Simulation" target="_blank">View the GitHub Repository</a>
        </section>

        <section>
            <h2>E-Field Simulation</h2>
            <img src="images/e_field_simulation_Remy.png" alt="E-Field Simulation Image" style="max-width:100%; height:auto; border-radius:8px;">
            <p>Explore the Electric Field Simulation on GitHub:</p>
            <a href="https://github.com/CohanR/TMS_ElectricField_Group_Simulation" target="_blank">View the GitHub Repository</a>
        </section>

        <section>
            <h2>Propofol and MEPs ML Model</h2>
            <img src="images/decision_tree_RC.png" alt="Decision Tree Image" style="max-width:100%; height:auto; border-radius:8px;">
            <p>Explore the Machine Learning Algorithm to Predict Whether Handedness and Propofol Dosage have any effects on MEP amplitudes on GitHub:</p>
            <a href="https://github.com/CohanR/MotorEvokedPotentials_Propofol_ML" target="_blank">View the GitHub Repository</a>
        </section>
    </main>

    <script>
        /* --- Quick Links toggle (click only) --- */
        function toggleSidebar() {
            const sidebar = document.getElementById('quicklinksSidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const btn = document.querySelector('.quicklinks-btn');

            const isOpen = sidebar.classList.contains('open');
            if (isOpen) {
                closeSidebar();
            } else {
                sidebar.classList.add('open');
                overlay.classList.add('open');
                if (btn) btn.setAttribute('aria-expanded', 'true');
            }
        }

        function closeSidebar() {
            const sidebar = document.getElementById('quicklinksSidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const btn = document.querySelector('.quicklinks-btn');

            sidebar.classList.remove('open');
            overlay.classList.remove('open');
            if (btn) btn.setAttribute('aria-expanded', 'false');
        }

        // Close on ESC
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeSidebar();
        });

        // --- SIMULATION LOGIC---
        const params = {
            C_m: 1.0, g_Na: 120.0, E_Na: 50.0,
            g_K: 36.0, E_K: -77.0, g_L: 0.3, E_L: -54.4,
            I_ext: 10.0, dt: 0.05
        };
    
        let state = { V: -65.0, m: 0.05, h: 0.6, n: 0.32, t: 0 };
        const historyLength = 800; 
        let vHistory = new Array(historyLength).fill(-65);
        let iHistory = new Array(historyLength).fill(0);
    
        function runTimeStep() {
            let { V, m, h, n } = state;
            if (isNaN(V) || !isFinite(V) || Math.abs(V) > 500) {
                state.V = -65.0; state.m = 0.05; state.h = 0.6; state.n = 0.32;
                return -65.0; 
            }

            const { g_Na, E_Na, g_K, E_K, g_L, E_L, I_ext, C_m, dt } = params;
            
            const alpha_n = (v) => 0.01 * (v + 55) / (1 - Math.exp(-(v + 55) / 10));
            const beta_n  = (v) => 0.125 * Math.exp(-(v + 65) / 80);
            const alpha_m = (v) => 0.1 * (v + 40) / (1 - Math.exp(-(v + 40) / 10));
            const beta_m  = (v) => 4 * Math.exp(-(v + 65) / 18);
            const alpha_h = (v) => 0.07 * Math.exp(-(v + 65) / 20);
            const beta_h  = (v) => 1 / (1 + Math.exp(-(v + 35) / 10));
    
            const I_Na = g_Na * Math.pow(m, 3) * h * (V - E_Na);
            const I_K  = g_K  * Math.pow(n, 4) * (V - E_K);
            const I_L  = g_L  * (V - E_L);
            const dV = (I_ext - I_Na - I_K - I_L) / C_m;
            
            state.V += dV * dt;
            state.m += (alpha_m(V)*(1-m) - beta_m(V)*m) * dt;
            state.h += (alpha_h(V)*(1-h) - beta_h(V)*h) * dt;
            state.n += (alpha_n(V)*(1-n) - beta_n(V)*n) * dt;
            return state.V;
        }
    
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        let speedMult = 0.8; // Slow speed
    
        function animate() {
            if(canvas.width !== canvas.offsetWidth) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }

            for(let i=0; i < speedMult * 5; i++) {
                const newV = runTimeStep();
                vHistory.shift();
                vHistory.push(newV);
                iHistory.shift();
                iHistory.push(params.I_ext);
            }
            draw();
            requestAnimationFrame(animate);
        }
    
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const vMin = -90, vMax = 60;
            const yScale = canvas.height / (vMax - vMin);
            
            // Grid
            ctx.strokeStyle = '#eee'; ctx.lineWidth = 1; ctx.beginPath();
            const zeroY = canvas.height - (0 - vMin) * yScale;
            ctx.moveTo(0, zeroY); ctx.lineTo(canvas.width, zeroY);
            const restY = canvas.height - (-65 - vMin) * yScale;
            ctx.strokeStyle = '#ddd'; ctx.setLineDash([5, 5]);
            ctx.moveTo(0, restY); ctx.lineTo(canvas.width, restY);
            ctx.stroke(); ctx.setLineDash([]);
    
            // Traces
            ctx.beginPath(); ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 2;
            for (let i = 0; i < historyLength; i++) {
                if (isNaN(vHistory[i])) continue;
                const x = (i / historyLength) * canvas.width;
                const y = canvas.height - (vHistory[i] - vMin) * yScale;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
    
            ctx.beginPath(); ctx.strokeStyle = '#3498db'; ctx.lineWidth = 1; ctx.globalAlpha = 0.5;
            for (let i = 0; i < historyLength; i++) {
                const x = (i / historyLength) * canvas.width;
                const y = canvas.height - 10 - (iHistory[i] / 50) * 50; 
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke(); ctx.globalAlpha = 1.0;

            // Labels
            ctx.fillStyle = '#444'; ctx.font = 'bold 12px Poppins, sans-serif';
            ctx.fillText("Voltage (mV)", 10, 20);
            ctx.fillText("Time →", canvas.width - 80, canvas.height - 20);
            ctx.fillStyle = '#999'; ctx.fillText("-65mV", 5, restY - 5);
        }
    
        const inputs = [
            { id: 'i_ext', param: 'I_ext' }, { id: 'g_na', param: 'g_Na' }, { id: 'e_na', param: 'E_Na' },
            { id: 'g_k', param: 'g_K' }, { id: 'e_k', param: 'E_K' }
        ];
    
        function updateUI() {
             inputs.forEach(item => {
                document.getElementById(item.id).value = params[item.param];
                document.getElementById('val_' + item.id).textContent = params[item.param] + (item.param.includes('E') ? ' mV' : (item.param.includes('I') ? ' µA' : ' mS'));
            });
        }

        inputs.forEach(item => {
            document.getElementById(item.id).addEventListener('input', (e) => {
                params[item.param] = parseFloat(e.target.value);
                updateUI();
            });
        });
    
        function applyPreset(type) {
            if(type === 'normal') { params.g_Na=120; params.E_Na=50; params.g_K=36; params.E_K=-77; params.I_ext=10; }
            else if (type === 'low_na') { params.g_Na=30; params.E_Na=50; params.g_K=36; params.E_K=-77; params.I_ext=10; }
            else if (type === 'high_k') { params.g_Na=120; params.E_Na=50; params.g_K=36; params.E_K=-40; params.I_ext=10; }
            state.V = -65.0; updateUI();
        }

        function resetDefaults() {
            params.I_ext=10; params.g_Na=120; params.E_Na=50; params.g_K=36; params.E_K=-77;
            state.V=-65.0; state.m=0.05; state.h=0.6; state.n=0.32;
            vHistory.fill(-65.0); updateUI();
        }

        updateUI(); animate();

        /* =========================
           McCulloch–Pitts simulation
           ========================= */

        const mp = {
            x1: 1, x2: 1,
            w1: 1.0, w2: 1.0,
            b: 0.0,
            th: 1.5
        };

        const mpEls = {
            canvas: document.getElementById('mpCanvas'),
            x1: document.getElementById('mp_x1'),
            x2: document.getElementById('mp_x2'),
            w1: document.getElementById('mp_w1'),
            w2: document.getElementById('mp_w2'),
            b: document.getElementById('mp_b'),
            th: document.getElementById('mp_th'),
            val_w1: document.getElementById('val_mp_w1'),
            val_w2: document.getElementById('val_mp_w2'),
            val_b: document.getElementById('val_mp_b'),
            val_th: document.getElementById('val_mp_th'),
            readout: document.getElementById('mp_readout'),
            math: document.getElementById('mp_math')
        };

        // Defensive: if someone deletes the section later, do nothing instead of throwing errors
        const mpHasDOM = mpEls.canvas && mpEls.x1 && mpEls.x2 && mpEls.w1 && mpEls.w2 && mpEls.b && mpEls.th;

        let mpCtx = null;
        if (mpHasDOM) mpCtx = mpEls.canvas.getContext('2d');

        function mpStep(x1, x2, w1, w2, b, th) {
            const s = (w1 * x1) + (w2 * x2) + b;
            const y = (s >= th) ? 1 : 0;
            return { s, y };
        }

        function mpTruthTable(w1, w2, b, th) {
            const rows = [
                { x1:0, x2:0 },
                { x1:0, x2:1 },
                { x1:1, x2:0 },
                { x1:1, x2:1 }
            ];
            return rows.map(r => {
                const out = mpStep(r.x1, r.x2, w1, w2, b, th);
                return { ...r, s: out.s, y: out.y };
            });
        }

        function mpUpdateFromUI() {
            if (!mpHasDOM) return;

            mp.x1 = mpEls.x1.checked ? 1 : 0;
            mp.x2 = mpEls.x2.checked ? 1 : 0;
            mp.w1 = parseFloat(mpEls.w1.value);
            mp.w2 = parseFloat(mpEls.w2.value);
            mp.b  = parseFloat(mpEls.b.value);
            mp.th = parseFloat(mpEls.th.value);

            mpEls.val_w1.textContent = mp.w1.toFixed(1);
            mpEls.val_w2.textContent = mp.w2.toFixed(1);
            mpEls.val_b.textContent  = mp.b.toFixed(1);
            mpEls.val_th.textContent = mp.th.toFixed(1);

            mpRender();
        }

        function mpApplyPreset(type) {
            if (!mpHasDOM) return;

            if (type === 'AND')   { mp.w1 = 1;  mp.w2 = 1;  mp.b = 0;  mp.th = 1.5; }
            if (type === 'OR')    { mp.w1 = 1;  mp.w2 = 1;  mp.b = 0;  mp.th = 0.5; }
            if (type === 'NAND')  { mp.w1 = -1; mp.w2 = -1; mp.b = 0;  mp.th = -1.5; }
            if (type === 'NOT_X1'){ mp.w1 = -2; mp.w2 = 0;  mp.b = 0;  mp.th = -1.0; }

            mpEls.w1.value = mp.w1;
            mpEls.w2.value = mp.w2;
            mpEls.b.value  = mp.b;
            mpEls.th.value = mp.th;

            mpUpdateFromUI();
        }

        function mpReset() {
            if (!mpHasDOM) return;

            mpEls.x1.checked = true;
            mpEls.x2.checked = true;
            mpEls.w1.value = 1;
            mpEls.w2.value = 1;
            mpEls.b.value  = 0;
            mpEls.th.value = 1.5;
            mpUpdateFromUI();
        }

        /* ADDED: HiDPI resize so the canvas is crisp (no blur / dirty lines) */
        function mpResizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = mpEls.canvas.getBoundingClientRect();

            mpEls.canvas.width = Math.round(rect.width * dpr);
            mpEls.canvas.height = Math.round(rect.height * dpr);

            // draw in CSS pixels
            mpCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function mpRender() {
            if (!mpHasDOM) return;

            mpResizeCanvas();

            const rect = mpEls.canvas.getBoundingClientRect();
            const W = rect.width;
            const H = rect.height;

            mpCtx.clearRect(0, 0, W, H);

            const { s, y } = mpStep(mp.x1, mp.x2, mp.w1, mp.w2, mp.b, mp.th);

            mpEls.readout.textContent = `y = ${y}`;
            const net = s - mp.th;
            mpEls.math.textContent =
                `s = w1·x1 + w2·x2 + b = ${mp.w1.toFixed(1)}·${mp.x1} + ${mp.w2.toFixed(1)}·${mp.x2} + ${mp.b.toFixed(1)} = ${s.toFixed(2)};  net = s − θ = ${net.toFixed(2)};  fire if net ≥ 0`;

            // Layout
            const xIn = 90;
            const y1 = H * 0.35;
            const y2 = H * 0.65;
            const xN = W * 0.55;
            const yN = H * 0.50;
            const rN = Math.min(55, Math.max(40, H * 0.16));
            const xOut = W - 70;
            const yOut = yN;

            // Cleaner line joins/caps
            mpCtx.lineCap = 'round';
            mpCtx.lineJoin = 'round';

            // Wires
            mpCtx.lineWidth = 3;
            mpCtx.strokeStyle = '#111';
            mpCtx.beginPath();
            mpCtx.moveTo(xIn, y1); mpCtx.lineTo(xN - rN, yN - 18);
            mpCtx.moveTo(xIn, y2); mpCtx.lineTo(xN - rN, yN + 18);
            mpCtx.stroke();

            // Input nodes
            function drawInput(x, y, label, val) {
                mpCtx.fillStyle = '#fff';
                mpCtx.strokeStyle = '#111';
                mpCtx.lineWidth = 2;
                mpCtx.beginPath();
                mpCtx.arc(x, y, 18, 0, Math.PI * 2);
                mpCtx.fill();
                mpCtx.stroke();

                mpCtx.fillStyle = '#111';
                mpCtx.font = 'bold 14px Poppins, sans-serif';
                mpCtx.fillText(label, x - 12, y - 26);

                mpCtx.font = 'bold 14px Poppins, sans-serif';
                mpCtx.fillText(String(val), x - 4, y + 5);
            }

            drawInput(xIn, y1, 'x1', mp.x1);
            drawInput(xIn, y2, 'x2', mp.x2);

            // Neuron body
            mpCtx.fillStyle = '#fff';
            mpCtx.strokeStyle = '#111';
            mpCtx.lineWidth = 3;
            mpCtx.beginPath();
            mpCtx.arc(xN, yN, rN, 0, Math.PI * 2);
            mpCtx.fill();
            mpCtx.stroke();

            // Neuron label (FIXED: not Σ + θ)
            mpCtx.fillStyle = '#111';
            mpCtx.font = 'bold 14px Poppins, sans-serif';
            mpCtx.fillText('Σ ≥ θ', xN - 18, yN + 5);

            // Output wire + node
            mpCtx.strokeStyle = '#111';
            mpCtx.lineWidth = 3;
            mpCtx.beginPath();
            mpCtx.moveTo(xN + rN, yN); mpCtx.lineTo(xOut - 18, yOut);
            mpCtx.stroke();

            mpCtx.fillStyle = '#fff';
            mpCtx.strokeStyle = '#111';
            mpCtx.lineWidth = 2;
            mpCtx.beginPath();
            mpCtx.arc(xOut, yOut, 18, 0, Math.PI * 2);
            mpCtx.fill();
            mpCtx.stroke();

            mpCtx.fillStyle = '#111';
            mpCtx.font = 'bold 14px Poppins, sans-serif';
            mpCtx.fillText('y', xOut - 4, yOut - 26);
            mpCtx.fillText(String(y), xOut - 4, yOut + 5);

            // Halo when firing
            if (y === 1) {
                mpCtx.globalAlpha = 0.12;
                mpCtx.fillStyle = '#e74c3c';
                mpCtx.beginPath();
                mpCtx.arc(xN, yN, rN + 14, 0, Math.PI * 2);
                mpCtx.fill();
                mpCtx.globalAlpha = 1.0;
            }

            // Truth table (boxed + highlighted row)
            const table = mpTruthTable(mp.w1, mp.w2, mp.b, mp.th);
            const cardW = 170;
            const cardH = 120;
            
            // put the truth table in the bottom-right so it never covers inputs/wires
            const tx = W - cardW - 16;
            const ty = H - cardH - 16;


            // Draw card
            mpCtx.fillStyle = '#fff';
            mpCtx.strokeStyle = '#e5e5e5';
            mpCtx.lineWidth = 1;
            mpCtx.beginPath();
            if (mpCtx.roundRect) {
                mpCtx.roundRect(tx, ty, cardW, cardH, 8);
            } else {
                // fallback if roundRect unsupported
                mpCtx.rect(tx, ty, cardW, cardH);
            }
            mpCtx.fill();
            mpCtx.stroke();

            mpCtx.fillStyle = '#333';
            mpCtx.font = '600 13px Poppins, sans-serif';
            mpCtx.fillText('Truth table', tx + 12, ty + 22);

            mpCtx.font = '12px Poppins, sans-serif';
            mpCtx.fillText('x1  x2    s     y', tx + 12, ty + 40);

            // highlight current input row
            const activeIndex =
                (mp.x1 === 0 && mp.x2 === 0) ? 0 :
                (mp.x1 === 0 && mp.x2 === 1) ? 1 :
                (mp.x1 === 1 && mp.x2 === 0) ? 2 : 3;

            const rowY0 = ty + 56;
            const rowH = 16;

            mpCtx.globalAlpha = 0.12;
            mpCtx.fillStyle = '#2E86C1';
            mpCtx.fillRect(tx + 8, rowY0 + activeIndex * rowH - 12, cardW - 16, 18);
            mpCtx.globalAlpha = 1.0;

            table.forEach((row, i) => {
                const sStr = row.s.toFixed(1).padStart(4, ' ');
                const line = `${row.x1}   ${row.x2}   ${sStr}   ${row.y}`;
                mpCtx.fillStyle = (i === activeIndex) ? '#111' : '#444';
                mpCtx.fillText(line, tx + 12, rowY0 + i * rowH);
            });
        }

        if (mpHasDOM) {
            // Hook up UI listeners
            ['change', 'input'].forEach(evt => {
                mpEls.x1.addEventListener(evt, mpUpdateFromUI);
                mpEls.x2.addEventListener(evt, mpUpdateFromUI);
                mpEls.w1.addEventListener(evt, mpUpdateFromUI);
                mpEls.w2.addEventListener(evt, mpUpdateFromUI);
                mpEls.b.addEventListener(evt, mpUpdateFromUI);
                mpEls.th.addEventListener(evt, mpUpdateFromUI);
            });

            // Initialise
            mpReset();

            // Keep it responsive on resize too (no lag / no surprises)
            window.addEventListener('resize', () => mpRender());
        }
    </script>
</body>
</html>
